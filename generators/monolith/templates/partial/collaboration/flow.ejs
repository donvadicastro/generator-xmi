<% let loops = {}; currentLoopId = null; %>
<% (entity.messages || []).forEach(message => { %>
    <% const loopFrom = message.from && message.fromOperand && message.from.elementRef.fragments.find(x => x.interactionOperator === 'loop') %>
    <% const loopTo = message.to && message.toOperand && message.to.elementRef.fragments.find(x => x.interactionOperator === 'loop') %>
    <% const loop = loopFrom || loopTo %>

    <% if(currentLoopId && (!loop || loop.id !== currentLoopId)) { %>
        <% //when loop completed - activate parent loop or skip
            delete loops[currentLoopId];
            const loopIds = Object.keys(loops);

            currentLoopId = loopIds.length ? loop[loopIds[loopIds.length-1]] : null;
        %>
                    return flowAsync;
                }));
            }).then(states => state);
        });
    <% } %>

    <% if(loop && !loops[loop.id]) { %>
        <% loops[loop.id] = message.from.elementRef; currentLoopId = loop.id; %>
        // <%= message.from ? message.from.elementRef.name : 'Start' %> call <%= message.to && message.to.elementRef.name %>
        flowAsync = flowAsync.then((state: any) => {
            return Promise.resolve(state).then(state => {
                return Promise.all(state.returns.map((x: any) => {
                    let flowAsync = Promise.resolve({...state, ...{returns: x}});
    <% } %>

    // <%= message.from ? message.from.elementRef.name : 'Start' %> call <%= message.to && message.to.elementRef.name %>
    flowAsync = flowAsync.then((state: any) => {
        <%- include('action', {message: message}) -%>
    });
<% }) %>
<% Object.keys(loops).reverse().forEach(x => { %>
            return flowAsync;
        }));
    }).then(states => state);
});
<% }) %>
