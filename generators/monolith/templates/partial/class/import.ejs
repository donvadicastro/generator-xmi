import {Entity, PrimaryGeneratedColumn, OneToMany, ManyToOne, ObjectID, ObjectIdColumn} from "typeorm";
import {Column} from "typeorm/decorator/columns/Column";
import {OneToOne} from "typeorm/decorator/relations/OneToOne";
import {JoinColumn} from "typeorm/decorator/relations/JoinColumn";
import {ManyToMany} from "typeorm/decorator/relations/ManyToMany";
import {JoinTable} from "typeorm/decorator/relations/JoinTable";
import {PrimaryColumn} from "typeorm/decorator/columns/PrimaryColumn";

import {ComponentBase} from '../<%= entity.getRelativeRoot() %>/base/componentBase';

<%
    var imports = {};
    imports['../../contracts/' + entity.name] = entity.name + 'Contract';

    if(entity.generalizationLinksTo) {
        imports[entity.generalizationLinksTo.name + 'Base'] = '../' + entity.getRelativePath(entity.generalizationLinksTo) + '/components/generated/' + entity.generalizationLinksTo.name + '.generated';
    }

    (entity.provided || []).forEach(value => {
        if(value.name) {
            imports['../' + entity.getRelativePath(value.ref) + '/contracts/' + value.name] = value.name + 'Contract';

            (value.ref.attributes || []).filter(x => x.typeRef).forEach(function (attribute) {
                imports['../' + entity.getRelativePath(attribute.typeRef) + '/contracts/' + attribute.typeRef.name] = attribute.typeRef.name  + 'Contract';
            });
        }
    });

    (entity.required || []).forEach(value => {
        imports['../' + entity.getRelativePath(value.ref) + '/contracts/' + value.name] = value.name + 'Contract';
    });

    //Inject base interface when instance speciaification is used
    (entity.associationLinks || []).forEach(x => {
        imports['../' + entity.getRelativePath(x.target.typeRef) + '/contracts/' + x.target.typeRef.name] = x.target.typeRef.name  + 'Contract';
        imports['../' + entity.getRelativePath(x.target.typeRef) + '/components/generated/' + x.target.typeRef.name + '.generated'] = x.target.typeRef.name  + 'Base';
    });

    (entity.aggregationLinks || []).forEach(x => {
        imports['../' + entity.getRelativePath(x.target.typeRef) + '/contracts/' + x.target.typeRef.name] = x.target.typeRef.name + 'Contract';
        imports['../' + entity.getRelativePath(x.target.typeRef) + '/components/generated/' + x.target.typeRef.name + '.generated'] = x.target.typeRef.name + 'Base';
    });

    //Inject base class when instance speciaification is used
    if (entity.elementRef) {
        imports['../' + entity.getRelativePath(entity.elementRef) + '/components/' + entity.elementRef.name] = entity.elementRef.name;
    }

    //Inject attributes type
    (entity.attributes || []).forEach(attribute => {
        if(attribute.typeRef) {
            imports['../' + entity.getRelativePath(attribute.typeRef) + '/contracts/' + attribute.typeRef.name] = attribute.typeRef.name + 'Contract';
        }
    });

    //Inject operation parameters and return types
    (entity.operations || []).forEach(operation => {
        if(operation.returnParameter.typeRef) {
            imports['../' + entity.getRelativePath(operation.returnParameter.typeRef) + '/contracts/' + operation.returnParameter.typeRef.name] = operation.returnParameter.typeRef.name + 'Contract';
        }
    });
%>

<% Object.keys(imports).sort((a, b) => imports[a] > imports[b] ? 1 : -1).forEach(key => {%>
    import {<%= imports[key] %>} from '<%= key %>';
<% }) %>
import {Promise} from 'es6-promise';
